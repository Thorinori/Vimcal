use enigo::{self, Enigo, Settings};
use vosk;
use cpal::{self, traits::{DeviceTrait, HostTrait, StreamTrait}, InputCallbackInfo, Sample, SampleFormat};


fn main() {
    //Set up input simulator
    let mut _enigo = Enigo::new(&Settings::default()).unwrap();


    //Set up Vosk
    let mut model = vosk::Model::new("model/").unwrap();

    let words = ["space", "control", "alt", "tab", "enter", "back", 
                "slash", "comma", "apostrophe", "tick","period","mod",
                "dot" ,"up", "down", "left", "right", "curly", "brace",
                "left", "right", "parenthesis", "parentheses", "plus", "minus",
                "ampersand", "pound", "exclamation", "point", "question",
                "mark", "semi", "colon", "quotation", "at", "percent", "carrot",
                "star", "splat", "under", "score", "underscore", "bracket", "angle",
                "pipe", "escape", "function", "a", "b", "c", "d", "e", "f", "g", "h",
                "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v",
                "w", "x", "y", "z", "one", "two", "three", "four", "five", "fix", "seven",
                "eight", "nine", "ten", "zero", "negative", "positive", "hundred", "thousand",
                "million", "billion", "trillion", "page", "home", "insert", "delete", "end",
                "scroll", "lock", "print", "screen", "pause", "num", "dollar", "shift", "return",
                "escape", 
    ];
    for word in words{
        if let None = model.find_word(word) {
            println!("Model couldn't find word: {}", word);
        }
    }
    
    //Get Microphone Input
    let host = cpal::default_host();
    let input_device = host.default_input_device().expect("Missing Input Device");
    println!("Input Device: {}", input_device.name().unwrap());
    let mut supported_configs = input_device.supported_input_configs().expect("Error Querying Device Configs");
    let supported_config = supported_configs.next().expect("No Supported Configs!").with_max_sample_rate();
    let sample_format = supported_config.sample_format();
    let config = supported_config.into();
    let err_fn = |err| eprint!("Error Occured on the Input Audio Stream: {}", err);
    let stream = match sample_format{
        SampleFormat::F32 => input_device.build_input_stream(&config, process_input::<f32>,err_fn , None),
        SampleFormat::I16 => input_device.build_input_stream(&config, process_input::<i16>,err_fn , None),
        SampleFormat::U16 => input_device.build_input_stream(&config, process_input::<u16>,err_fn , None),
        SampleFormat::U8  => input_device.build_input_stream(&config, process_input::<u8>, err_fn , None),
        sample_format => panic!("Unsupported Sample Format '{sample_format}'")
    }.unwrap();
    
    stream.play().unwrap();
    std::thread::sleep(std::time::Duration::from_secs(2));
}

fn process_input<T: Sample>(data: &[T], _: &cpal::InputCallbackInfo){
    for _sample in data.iter(){
        println!("Doing a thing!"); 
    }
}
